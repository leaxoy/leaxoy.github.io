<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Rust异步浅谈 | 无双</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="一枚热爱工作的小白"><link rel="prev" href="https://leaxoy.github.io/2019/12/go-concurrent-saft-and-unsafe/" /><link rel="canonical" href="https://leaxoy.github.io/2020/03/rust-async-runtime/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><meta property="og:title" content="Rust异步浅谈" />
<meta property="og:description" content="前提 这篇文章主要描述了Rust中异步的原理，Rust异步也是在最近的版本中(1.39)中才稳定下来。希望可以通过这边文章在提高自己认知的情况" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leaxoy.github.io/2020/03/rust-async-runtime/" />
<meta property="article:published_time" content="2020-03-10T12:37:36+08:00" />
<meta property="article:modified_time" content="2020-03-10T12:37:36+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust异步浅谈"/>
<meta name="twitter:description" content="前提 这篇文章主要描述了Rust中异步的原理，Rust异步也是在最近的版本中(1.39)中才稳定下来。希望可以通过这边文章在提高自己认知的情况"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Rust异步浅谈",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/leaxoy.github.io\/2020\/03\/rust-async-runtime\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/leaxoy.github.io\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "rust, 并发","wordcount":  3881 ,
        "url": "https:\/\/leaxoy.github.io\/2020\/03\/rust-async-runtime\/","datePublished": "2020-03-10T12:37:36\x2b08:00","dateModified": "2020-03-10T12:37:36\x2b08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "李大辉",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/leaxoy.github.io\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"description": ""
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/css/lib/animate/animate.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://leaxoy.github.io/">无双</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://leaxoy.github.io/posts" title="">文章</a><a class="menu-item" href="https://leaxoy.github.io/tags" title="">标签</a><a class="menu-item" href="https://leaxoy.github.io/categories" title="">分类</a><a class="menu-item" href="https://leaxoy.github.io/about" title="">关于</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://leaxoy.github.io/">无双</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://leaxoy.github.io/posts" title="">文章</a><a class="menu-item" href="https://leaxoy.github.io/tags" title="">标签</a><a class="menu-item" href="https://leaxoy.github.io/categories" title="">分类</a><a class="menu-item" href="https://leaxoy.github.io/about" title="">关于</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><article class="page"><h1 class="post-title animated flipInX">Rust异步浅谈</h1><div class="post-meta">
            <div class="post-meta-main"><a class="author" href="https://leaxoy.github.io/" rel="author" target="_blank">
                    <i class="fas fa-user-circle fa-fw"></i>李大辉
                </a>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i><a href="https://leaxoy.github.io/categories/rust/">Rust</a>&nbsp;</span></div>
            <div class="post-meta-other"><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-03-10>2020-03-10</time>&nbsp;
                <i class="fas fa-pencil-alt fa-fw"></i>约 3881 字&nbsp;
                <i class="far fa-clock fa-fw"></i>预计阅读 8 分钟&nbsp;</div>
        </div><div class="post-toc" id="post-toc">
                <h2 class="post-toc-title">目录</h2>
                <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#前提">前提</a></li>
    <li><a href="#future">Future</a>
      <ul>
        <li><a href="#future结构">Future结构</a></li>
      </ul>
    </li>
    <li><a href="#runtime">Runtime</a>
      <ul>
        <li><a href="#执行流程">执行流程</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#executor">Executor</a></li>
    <li><a href="#reactor">Reactor</a></li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#sink">Sink</a></li>
    <li><a href="#timer">Timer</a></li>
    <li><a href="#组合子">组合子</a></li>
    <li><a href="#asyncawait">Async/Await</a></li>
    <li><a href="#总结-1">总结</a></li>
  </ul>
</nav></div>
            </div>
            <div class="post-toc-mobile" id="post-toc-mobile">
                <details>
                    <summary>
                        <div class="post-toc-title">
                            <span>目录</span>
                            <span><i class="details icon fas fa-angle-down"></i></span>
                        </div>
                    </summary>
                    <div class="post-toc-content"><nav id="TableOfContentsMobile">
  <ul>
    <li><a href="#前提">前提</a></li>
    <li><a href="#future">Future</a>
      <ul>
        <li><a href="#future结构">Future结构</a></li>
      </ul>
    </li>
    <li><a href="#runtime">Runtime</a>
      <ul>
        <li><a href="#执行流程">执行流程</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#executor">Executor</a></li>
    <li><a href="#reactor">Reactor</a></li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#sink">Sink</a></li>
    <li><a href="#timer">Timer</a></li>
    <li><a href="#组合子">组合子</a></li>
    <li><a href="#asyncawait">Async/Await</a></li>
    <li><a href="#总结-1">总结</a></li>
  </ul>
</nav></div>
                </details>
            </div><div class="post-content"><a class="post-dummy-target" id="前提"></a><h2>前提</h2>
<p>  这篇文章主要描述了Rust中异步的原理，Rust异步也是在最近的版本中(1.39)中才稳定下来。希望可以通过这边文章在提高自己认知的情况下，也可以给读者带来一些解惑。(<strong>来自于本人被Rust异步毒打的一些经验之谈</strong>).</p>
<p>  阅读这篇文章需要对操作系统，IO多路复用，以及一些数据结构有一定的概念。</p>
<a class="post-dummy-target" id="future"></a><h2>Future</h2>
<p>  <code>Future</code> 字面的意思就是未来发生的事情，在程序中则代表了一系列暂时没有结果的运算子，<code>Future</code>需要程序主动去<code>poll</code>(轮询)才能获取到最终的结果，每一次轮询的结果可能是<code>Ready</code>或者<code>Pending</code>。</p>
<p>  当<code>Ready</code>的时候，证明当前<code>Future</code>已完成，代码逻辑可以向下执行；当<code>Pending</code>的时候，代表当前<code>Future</code>并未执行完成，代码不能向下执行，看到这里就要问了，拿什么时候才能向下执行呢，这里的关键在于<code>Runtime</code>中的<code>Executor</code>需要不停的去执行<code>Future</code>的<code>poll</code>操作，直至<code>Future</code>返回<code>Ready</code>可以向下执行为止。等等，熟悉<code>Linux</code>的同学可能要说了，怎么感觉和<code>Epoll</code>模型是非常的相似呢，没错，这确实非常相像(但是依然有些许不通，<code>Future</code>可以避免空的轮询)，看样子优秀的设计在哪里都可以看到类似的身影。为了实现Rust声称的高性能与零开销抽象，这里做了一些优化，下面一一讲述。</p>
<a class="post-dummy-target" id="future结构"></a><h3>Future结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Ready</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Pending</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Future</code>的定义非常简单，<code>Output</code>代表了<code>Future</code>返回的值的类型，而<code>poll</code>方法是执行<code>Future</code>的关键，<code>poll</code>方法可以返回一个<code>Poll</code>类型，<code>Poll</code>类型是一个<code>Enum</code>，包装了<code>Ready</code>和<code>Pending</code>两种状态。</p>
<a class="post-dummy-target" id="runtime"></a><h2>Runtime</h2>
<p><code>Runtime</code> 由两部分组成，<code>Executor</code>和<code>Reactor</code>。</p>
<p><code>Executor</code>为执行器，没有任何阻塞的等待，循环执行一系列就绪的<code>Future</code>，当<code>Future</code>返回<code>pending</code>的时候，会将<code>Future</code>转移到<code>Reactor</code>上等待进一步的唤醒。</p>
<p><code>Reactor</code>为反应器(唤醒器)，轮询并唤醒挂在的事件，并执行对应的<code>wake</code>方法，通常来说，<code>wake</code>会将<code>Future</code>的状态变更为就绪，同时将<code>Future</code>放到<code>Executor</code>的队列中等待执行。</p>
<a class="post-dummy-target" id="执行流程"></a><h3>执行流程</h3>
<p>下面的序列图大概简单的描绘了<code>Future</code>在<code>Executor</code>和<code>Reactor</code>之间来回转移的流程与状态变化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    Executor-&gt;&gt;Reactor: Pending Future
    deactivate Executor
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: Ready Future
    deactivate Reactor
    activate Executor
    deactivate Executor
</code></pre></td></tr></table>
</div>
</div><p>上面说明了一个简单的<code>Future</code>的执行，如果是一个比较复杂的<code>Future</code>的话，比如中间会有多次<code>IO</code>操作的话，那么流程时怎么样的呢？看下面一段代码：(仅仅作为demo，不代表可以直接使用)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_and_write</span><span class="p">(</span><span class="n">s</span>: <span class="nc">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="n">buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#34;Hello,world&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">w</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">()).</span><span class="n">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对应的执行流程为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    deactivate Executor
    Executor-&gt;&gt;Reactor: Pending on r.read()
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: r.read() is ready
    Note left of Executor: Execute current Future
    deactivate Reactor
    Executor-&gt;&gt;Reactor: Pending on w.write_all()
    Note left of Executor: Execute other Future
    activate Reactor
    deactivate Reactor
    Reactor-&gt;&gt;Executor: w.write_all() is ready
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>  上面的这些例子系统中只展示了一个<code>Future</code>的执行情况，真实的生产环境中，可能有数十万的<code>Future</code>同时在执行，<code>Executor</code>和<code>Reactor</code>的调度模型要更复杂一些。</p>
</blockquote>
<a class="post-dummy-target" id="总结"></a><h3>总结</h3>
<p>一句话概括<code>Runtime</code>，<code>Future</code>不能马上返回值的时候，会被交给<code>Reactor</code>，<code>Future</code>的值准备就绪后，调用<code>wake</code>传递给<code>Executor</code>执行，反复执行，直至整个<code>Future</code>返回<code>Ready</code>。</p>
<a class="post-dummy-target" id="executor"></a><h2>Executor</h2>
<p>  通常来说，<code>Executor</code>的实现可以是单线程与线程池两个版本，两种实现间各有优劣，单线程少了数据的竞争，但是吞吐量却容易达到瓶颈，线程池的实现可以提高吞吐量，但是却要处理数据的竞争冲突。下面我们以<a href="https://github.com/async-rs/async-std" target="_blank"><code>async-std</code></a>来分析基于线程池的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main_loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">find_runnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 实际上，这里根据空循环的次数，会陷入睡眠状态或出让CPU资源，直到新的task来唤醒。
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">find_runnable</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_local</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_local</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">steal_other</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里做了大量的简化，整个Executor是一个线程池，每个线程都在不断的寻找可执行的task，然后执行，然后再找下一个task，再执行，永远重复。</p>
<blockquote>
<p>从上面的main_loop中可以看到，cpu并不是一直毫无意义的空转，中间会有一些策略来优化cpu的使用。</p>
</blockquote>
<a class="post-dummy-target" id="reactor"></a><h2>Reactor</h2>
<p>  <code>Reactor</code>作为反应器，上面同时挂在了成千上万个待唤醒的事件， 这里使用了<a href="https://github.com/&amp;emsp;tokio-rs/mio" target="_blank"><code>mio</code></a>统一封装了操作系统的多路复用<code>API</code>。在<code>Linux</code>中使用的是<a href="https://zh.wikipedia.org/wiki/Epoll" target="_blank"><code>Epoll</code></a>，在<code>Mac</code>中使用的则是<a href="https://zh.wikipedia.org/wiki/Kqueue" target="_blank"><code>Kqueue</code></a>，具体的实现在此不多说。</p>
<p>  在Future的基础上，出现了<code>AsyncRead/AsyncWrite/AsyncSeek</code>等抽象来描述IO操作，在执行对应的<code>Read/Write/Seek</code>操作时，如果底层的数据尚未准备好，会把所在的Future注册至Reactor。Reactor的流程如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">poll</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">events</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">is_readable</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readers</span><span class="p">.</span><span class="n">wakers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">waker</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">is_writeable</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">writers</span><span class="p">.</span><span class="n">wakers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">waker</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Reactor</code>会不断的<code>poll</code>就绪的事件，然后依次唤醒绑定在事件上的<code>waker</code>，<code>waker</code>唤醒的时候会把对应的<code>task</code>移动到<code>Executor</code>的就绪队列上安排执行。</p>
<blockquote>
<p>结合<code>Executor</code>的运作原理不难发现，<code>Executor</code>肯定不会<code>poll</code>到未就绪的<code>task</code>，因为只有就绪的任务才会被放到<code>Executor</code>的执行队列中，<code>Executor</code>的资源利用率再一次被提高，这就是整个异步体系的高明之处。</p>
</blockquote>
<a class="post-dummy-target" id="stream"></a><h2>Stream</h2>
<p>  <code>Future</code>是异步开发中最基础的概念了，如果说<code>Future</code>代表了一次性的异步的值，那么<code>Stream</code>则代表了一系列的异步的值。<code>Future</code>是1，<code>Stream</code>是0，1或者N。 签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Stream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_next</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>对应了同步原语中的<code>Iterator</code>的概念，想一下，是不是连签名都是如此的相像呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>用来抽象源源不断的数据源，当然也可以断。可以用来抽象<code>Websocket Connection</code>，在<code>Websokcet</code>中，服务源源不断的接受客户端的值并处理，直至客户端断开连接。更进一步的抽象，<code>MQ</code>中的<code>Consumer</code>, <code>Tcp</code>中的业务数据包，都可以看作是一个<code>Stream</code>, 因此<code>Stream</code>的抽象对异步编程意义非凡。</p>
<a class="post-dummy-target" id="sink"></a><h2>Sink</h2>
<p>有了代表一次性的异步值<code>Future</code>, 也有了代表可重复的异步值的<code>Stream</code>, 因此，需要有一个代表一次或多次的异步值，也就是接下来的<code>Sink</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_ready</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">start_send</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_flush</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_close</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="timer"></a><h2>Timer</h2>
<p>  不同于Tcp/Udp/Uds，mio没有提供对Timer的封装。</p>
<p>  通常来说，对定时器的处理要么是时间轮，要么堆，要么红黑树(时间复杂度更为平均O(logN))。时间轮比较典型的案例就是在<code>Kafka</code>中的使用了，<code>Go runtime</code>用的则是堆，红黑树和堆的实现大致相同。</p>
<ol>
<li>时间轮算法可以想象做钟表，每一格存储了到期的定时器，因此时间轮的最小精度为每一格所代表的时间。如果定时器的时间超过时间轮所能表示的时间怎么办呢，也简单，可以通过两种方式来优化。</li>
</ol>
<ul>
<li>多级时间轮来优化，可以想象，在钟表上，秒针每走一圈，分针走一格，同理分针走一圈，时针走一格，因此多级时间轮中，第一级的时间最为精确，第二级次之，第三级再次之&hellip;, 超过某一级时间轮所能表示的事件后，将定时器放到下一级时间轮中。</li>
<li>超过时间轮所能表示的时间范围后，对时间取余，插入到余数所在的格子中，这样一来，每个格子中存放的定时器需要加入轮数的记录，用来表明还差多少轮才能执行。每个格子中在插入新的定时器时，可以使用堆来堆定时器进行排序。</li>
</ul>
<ol start="2">
<li>堆定时器(红黑树定时器)</li>
</ol>
<p>  使用最小堆来维护所有的定时器。一个工作线程不断的从堆里面寻找最近的定时器，如果定时器的时间比当前时间小，则唤醒该定时器对应的task，如果未达到设定的时间，则进行<code>Thread::park(deadline-now)</code>操作，让出当前cpu一段时间。</p>
<blockquote>
<p>目前futures-timer的实现为全剧唯一的一个堆。存在可优化空间&hellip;</p>
</blockquote>
<a class="post-dummy-target" id="组合子"></a><h2>组合子</h2>
<p>上面定义了实现异步的最基本概念，<code>Future</code>, <code>Stream</code>以及<code>Sink</code>。</p>
<p>但是很多情况下，我们直接使用它们来构建我们的应用是非常困难的，例如：多个互为竞争关系的<code>Future</code>，我们只需其中任意一个<code>Future</code>返回即可，能想到的做法是，我们不断的遍历所有的<code>Future</code>，直到某一个返回<code>Ready</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">futures</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">is_ready</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">output</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们可以把上面的逻辑给包装一下，提供一个名为<code>select!(futures...)</code>的宏，<code>select</code>便可作为一个组合子而存在。类似的组合子还有很多，比如<code>join(futures...)</code>，等待所有<code>Future</code>完成。</p>
<p>更多的可以参考<a href="https://docs.rs/futures-util/0.3.4/futures_util/" target="_blank"><code>futures-util</code></a>.</p>
<a class="post-dummy-target" id="asyncawait"></a><h2>Async/Await</h2>
<p>上面所有的概念共同组成了<code>Rust</code>的异步生态，那么现在想象一下，如何获取一个<code>Future</code>运行的结果呢。一个可能的做法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span>::<span class="n">poll</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果每次都要用户这么做的话，将会是多么痛苦的一件事儿呀，还不如用注册回调函数来实现异步呢！</p>
<p>有没有更精炼的方式来获取<code>Future</code>的值呢，这就是<code>async/await</code>出现的原因了。本质上来说，<code>async/await</code>就是上面代码段的一个语法糖，是用户使用起来更加的自然。上面的代码可以替换成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">await</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>是不是有非常大的简化呢！</strong></p>
<a class="post-dummy-target" id="总结-1"></a><h2>总结</h2>
<p>虽然上面提到了各种各样的概念，但是仔细捋一下，便会发现整个异步可以分为三层：</p>
<ol>
<li>Future/Stream/Sink，Reactor/Executor直接作用于前面的三种类型。此层是为底层，一般用户很少接触，库的开发者接触较多。</li>
<li>组合子层，为了提供更为复杂的操作，诞生了一系列的异步组合子，使得异步变得更利于使用，用户会使用这些组合子来完成各种各样的逻辑。</li>
<li>async/await，准确的说，这层远没有上面两层来的重要，但是依然不可或缺，这层使得异步的开发变得轻而易举。</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>本文于 2020-03-10 更新</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"><span><a href="//twitter.com/share?url=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f&amp;text=Rust%e5%bc%82%e6%ad%a5%e6%b5%85%e8%b0%88&amp;via=lidahuiya" target="_blank" title="分享到 Twitter">
            <i class="fab fa-twitter fa-fw"></i>
        </a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f" target="_blank" title="分享到 Facebook">
            <i class="fab fa-facebook-square fa-fw"></i>
        </a><a href="//reddit.com/submit?url=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f&amp;title=Rust%e5%bc%82%e6%ad%a5%e6%b5%85%e8%b0%88" target="_blank" title="分享到 Reddit">
            <i class="fab fa-reddit fa-fw"></i>
        </a></span></div>
        </div>
    </div>

    <div class="post-info-more">
        <section><span class="tag">
                        <a href="https://leaxoy.github.io/tags/rust/"><i class="fas fa-tag fa-fw"></i>&nbsp;rust</a>&nbsp;
                    </span><span class="tag">
                        <a href="https://leaxoy.github.io/tags/%E5%B9%B6%E5%8F%91/"><i class="fas fa-tag fa-fw"></i>&nbsp;并发</a>&nbsp;
                    </span></section>
        <section>
            <span><a href="javascript:window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="https://leaxoy.github.io/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="https://leaxoy.github.io/2019/12/go-concurrent-saft-and-unsafe/" class="prev" rel="prev" title="Go语言并发安全与不安全"><i class="fas fa-angle-left fa-fw"></i>Go语言并发安全与不安全</a></div>
</div><div class="post-comment"></div>
    </article></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a>
        </div>

        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://leaxoy.github.io/" target="_blank">李大辉</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><script src="/js/blog.min.js"></script></body>
</html>
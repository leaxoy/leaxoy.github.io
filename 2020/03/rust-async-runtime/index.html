<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Rust异步浅谈 | 无双</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="一枚热爱工作的小白"><link rel="prev" href="https://leaxoy.github.io/2019/12/go-concurrent-saft-and-unsafe/" /><link rel="canonical" href="https://leaxoy.github.io/2020/03/rust-async-runtime/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><meta property="og:title" content="Rust异步浅谈" />
<meta property="og:description" content="前提 这篇文章主要描述了Rust中异步的原理与相关的实现，Rust异步也是在最近的版本(1.39)中才稳定下来。希望可以通过这边文章在提高自己" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leaxoy.github.io/2020/03/rust-async-runtime/" />
<meta property="article:published_time" content="2020-03-10T12:37:36+08:00" />
<meta property="article:modified_time" content="2020-03-10T12:37:36+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust异步浅谈"/>
<meta name="twitter:description" content="前提 这篇文章主要描述了Rust中异步的原理与相关的实现，Rust异步也是在最近的版本(1.39)中才稳定下来。希望可以通过这边文章在提高自己"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Rust异步浅谈",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/leaxoy.github.io\/2020\/03\/rust-async-runtime\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/leaxoy.github.io\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "rust, 并发","wordcount":  5314 ,
        "url": "https:\/\/leaxoy.github.io\/2020\/03\/rust-async-runtime\/","datePublished": "2020-03-10T12:37:36\x2b08:00","dateModified": "2020-03-10T12:37:36\x2b08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "李大辉",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/leaxoy.github.io\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"description": ""
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/css/lib/animate/animate.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://leaxoy.github.io/">无双</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://leaxoy.github.io/posts" title="">文章</a><a class="menu-item" href="https://leaxoy.github.io/tags" title="">标签</a><a class="menu-item" href="https://leaxoy.github.io/categories" title="">分类</a><a class="menu-item" href="https://leaxoy.github.io/about" title="">关于</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://leaxoy.github.io/">无双</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://leaxoy.github.io/posts" title="">文章</a><a class="menu-item" href="https://leaxoy.github.io/tags" title="">标签</a><a class="menu-item" href="https://leaxoy.github.io/categories" title="">分类</a><a class="menu-item" href="https://leaxoy.github.io/about" title="">关于</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><article class="page"><h1 class="post-title animated flipInX">Rust异步浅谈</h1><div class="post-meta">
            <div class="post-meta-main"><a class="author" href="https://leaxoy.github.io/" rel="author" target="_blank">
                    <i class="fas fa-user-circle fa-fw"></i>李大辉
                </a>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i><a href="https://leaxoy.github.io/categories/rust/">Rust</a>&nbsp;</span></div>
            <div class="post-meta-other"><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-03-10>2020-03-10</time>&nbsp;
                <i class="fas fa-pencil-alt fa-fw"></i>约 5314 字&nbsp;
                <i class="far fa-clock fa-fw"></i>预计阅读 11 分钟&nbsp;</div>
        </div><div class="post-toc" id="post-toc">
                <h2 class="post-toc-title">目录</h2>
                <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#前提">前提</a></li>
    <li><a href="#future">Future</a>
      <ul>
        <li><a href="#future结构">Future结构</a></li>
      </ul>
    </li>
    <li><a href="#context">Context</a></li>
    <li><a href="#runtime">Runtime</a>
      <ul>
        <li><a href="#执行流程">执行流程</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#executor">Executor</a></li>
    <li><a href="#reactor">Reactor</a></li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#sink">Sink</a></li>
    <li><a href="#timer">Timer</a></li>
    <li><a href="#组合子">组合子</a></li>
    <li><a href="#asyncawait">Async/Await</a></li>
    <li><a href="#总结-1">总结</a>
      <ul>
        <li><a href="#注意的地方">注意的地方</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div>
            <div class="post-toc-mobile" id="post-toc-mobile">
                <details>
                    <summary>
                        <div class="post-toc-title">
                            <span>目录</span>
                            <span><i class="details icon fas fa-angle-down"></i></span>
                        </div>
                    </summary>
                    <div class="post-toc-content"><nav id="TableOfContentsMobile">
  <ul>
    <li><a href="#前提">前提</a></li>
    <li><a href="#future">Future</a>
      <ul>
        <li><a href="#future结构">Future结构</a></li>
      </ul>
    </li>
    <li><a href="#context">Context</a></li>
    <li><a href="#runtime">Runtime</a>
      <ul>
        <li><a href="#执行流程">执行流程</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#executor">Executor</a></li>
    <li><a href="#reactor">Reactor</a></li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#sink">Sink</a></li>
    <li><a href="#timer">Timer</a></li>
    <li><a href="#组合子">组合子</a></li>
    <li><a href="#asyncawait">Async/Await</a></li>
    <li><a href="#总结-1">总结</a>
      <ul>
        <li><a href="#注意的地方">注意的地方</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </details>
            </div><div class="post-content"><a class="post-dummy-target" id="前提"></a><h2>前提</h2>
<p>  这篇文章主要描述了Rust中异步的原理与相关的实现，Rust异步也是在最近的版本(1.39)中才稳定下来。希望可以通过这边文章在提高自己认知的情况下，也可以给读者带来一些解惑。(<strong>来自于本人被Rust异步毒打的一些经验之谈</strong>).</p>
<p>  阅读这篇文章需要对操作系统，IO多路复用，以及一些数据结构有一定的概念。</p>
<p>  老生常谈，几乎所有的语言中异步相关的解释都是统一的：<strong>线程切换开销大，且资源浪费（主要集中在内存上）</strong>，这篇文章假定读者已对这些情况已知晓。</p>
<a class="post-dummy-target" id="future"></a><h2>Future</h2>
<p>  <code>Future</code> 字面的意思就是未来发生的事情，在程序中则代表了一系列暂时没有结果的运算子，<code>Future</code>需要程序主动去<code>poll</code>(轮询)才能获取到最终的结果，每一次轮询的结果可能是<code>Ready</code>或者<code>Pending</code>。</p>
<p>  当<code>Ready</code>的时候，证明当前<code>Future</code>已完成，代码逻辑可以向下执行；当<code>Pending</code>的时候，代表当前<code>Future</code>并未执行完成，代码不能向下执行，看到这里就要问了，那什么时候才能向下执行呢，这里的关键在于<code>Runtime</code>中的<code>Executor</code>需要不停的去执行<code>Future</code>的<code>poll</code>操作，直至<code>Future</code>返回<code>Ready</code>可以向下执行为止。等等，熟悉<code>Linux</code>的同学可能要说了，怎么感觉和<code>Epoll</code>模型是非常的相似呢，没错，这确实非常相像(但是依然有些许不通，<code>Future</code>可以避免空的轮询)，看样子优秀的设计在哪里都可以看到类似的身影。为了实现Rust声称的高性能与零开销抽象，这里做了一些优化，下面一一讲述。</p>
<a class="post-dummy-target" id="future结构"></a><h3>Future结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Ready</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Pending</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Future</code>的定义非常简单，<code>Output</code>代表了<code>Future</code>返回的值的类型，而<code>poll</code>方法是执行<code>Future</code>的关键，<code>poll</code>方法可以返回一个<code>Poll</code>类型，<code>Poll</code>类型是一个<code>Enum</code>，包装了<code>Ready</code>和<code>Pending</code>两种状态。</p>
<a class="post-dummy-target" id="context"></a><h2>Context</h2>
<p><code>Context</code>提供了对<code>Future</code>进行调度的功能。目前<code>Context</code>作为一个结构体，有一个核心成员<code>Waker</code>，用来唤醒绑定的<code>Future</code>. 未来不排除在<code>Context</code>添加新的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Context</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">waker</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Waker</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// Ensure we future-proof against variance changes by forcing
</span><span class="c1"></span><span class="w">    </span><span class="c1">// the lifetime to be invariant (argument-position lifetimes
</span><span class="c1"></span><span class="w">    </span><span class="c1">// are contravariant while return-position lifetimes are
</span><span class="c1"></span><span class="w">    </span><span class="c1">// covariant).
</span><span class="c1"></span><span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">())</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Waker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">waker</span>: <span class="nc">RawWaker</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Waker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 唤醒绑定在 Waker 上的数据，通常是 Future
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">will_wake</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Waker</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_raw</span><span class="p">(</span><span class="n">waker</span>: <span class="nc">RawWaker</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Waker</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RawWaker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// A data pointer, which can be used to store arbitrary data as required
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// by the executor. This could be e.g. a type-erased pointer to an `Arc`
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// that is associated with the task.
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// The value of this field gets passed to all functions that are part of
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// the vtable as the first parameter.
</span><span class="sd"></span><span class="w">    </span><span class="n">data</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Virtual function pointer table that customizes the behavior of this waker.
</span><span class="sd"></span><span class="w">    </span><span class="n">vtable</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="n">RawWakerVTable</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// RawWaker 行为的虚函数表
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RawWakerVTable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">clone</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">RawWaker</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">wake</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="n">wake_by_ref</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="n">drop</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">()),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="runtime"></a><h2>Runtime</h2>
<p><code>Runtime</code> 由两部分组成，<code>Executor</code>和<code>Reactor</code>。</p>
<p><code>Executor</code>为执行器，没有任何阻塞的等待，循环执行一系列就绪的<code>Future</code>，当<code>Future</code>返回<code>pending</code>的时候，会将<code>Future</code>转移到<code>Reactor</code>上等待进一步的唤醒。</p>
<p><code>Reactor</code>为反应器(唤醒器)，轮询并唤醒挂载的事件，并执行对应的<code>wake</code>方法，通常来说，<code>wake</code>会将<code>Future</code>的状态变更为就绪，同时将<code>Future</code>放到<code>Executor</code>的队列中等待执行。</p>
<a class="post-dummy-target" id="执行流程"></a><h3>执行流程</h3>
<p>下面的序列图大概简单的描绘了<code>Future</code>在<code>Executor</code>和<code>Reactor</code>之间来回转移的流程与状态变化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    Executor-&gt;&gt;Reactor: Pending Future
    deactivate Executor
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: Ready Future
    deactivate Reactor
    activate Executor
    deactivate Executor
</code></pre></td></tr></table>
</div>
</div><p><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://i.loli.net/2020/03/10/4Vst3WkrgJmw6G2.png" alt="rust-future" class="lazyload"><figcaption class="image-caption">rust-future</figcaption></figure></p>
<p>上面说明了一个简单的<code>Future</code>的执行，如果是一个比较复杂的<code>Future</code>的话，比如中间会有多次<code>IO</code>操作的话，那么流程时怎么样的呢？看下面一段代码：(仅仅作为demo，不代表可以直接使用)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_and_write</span><span class="p">(</span><span class="n">s</span>: <span class="nc">TcpStream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="n">buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#34;Hello,world&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">w</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">()).</span><span class="n">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对应的执行流程为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    deactivate Executor
    Executor-&gt;&gt;Reactor: Pending on r.read()
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: r.read() is ready
    Note left of Executor: Execute current Future
    deactivate Reactor
    Executor-&gt;&gt;Reactor: Pending on w.write_all()
    Note left of Executor: Execute other Future
    activate Reactor
    deactivate Reactor
    Reactor-&gt;&gt;Executor: w.write_all() is ready
</code></pre></td></tr></table>
</div>
</div><p><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://i.loli.net/2020/03/10/QYTsVfAuZBHyiEj.png" alt="rust-future-complex" class="lazyload"><figcaption class="image-caption">rust-future-complex</figcaption></figure></p>
<blockquote>
<p>  上面的这些例子系统中只展示了一个<code>Future</code>的执行情况，真实的生产环境中，可能有数十万的<code>Future</code>同时在执行，<code>Executor</code>和<code>Reactor</code>的调度模型要更复杂一些。</p>
</blockquote>
<a class="post-dummy-target" id="总结"></a><h3>总结</h3>
<p>一句话概括<code>Runtime</code>，<code>Future</code>不能马上返回值的时候，会被交给<code>Reactor</code>，<code>Future</code>的值准备就绪后，调用<code>wake</code>传递给<code>Executor</code>执行，反复执行，直至整个<code>Future</code>返回<code>Ready</code>。</p>
<a class="post-dummy-target" id="executor"></a><h2>Executor</h2>
<p>  通常来说，<code>Executor</code>的实现可以是单线程与线程池两个版本，两种实现间各有优劣，单线程少了数据的竞争，但是吞吐量却容易达到瓶颈，线程池的实现可以提高吞吐量，但是却要处理数据的竞争冲突。下面我们以<a href="https://github.com/async-rs/async-std" target="_blank"><code>async-std</code></a>来分析基于线程池的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// The state of an executor.
</span><span class="sd"></span><span class="k">struct</span> <span class="nc">Pool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 全局任务队列
</span><span class="sd"></span><span class="w">    </span><span class="n">injector</span>: <span class="nc">Injector</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 线程的本地队列，用来进行任务的偷取
</span><span class="sd"></span><span class="w">    </span><span class="n">stealers</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Stealer</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 存放空闲的线程，用来后续的唤醒并执行任务
</span><span class="sd"></span><span class="w">    </span><span class="n">sleepers</span>: <span class="nc">Sleepers</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 全局的线程池
</span><span class="c1"></span><span class="k">static</span><span class="w"> </span><span class="n">POOL</span>: <span class="nc">Lazy</span><span class="o">&lt;</span><span class="n">Pool</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Lazy</span>::<span class="n">new</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_cpus</span>::<span class="n">get</span><span class="p">().</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stealers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Spawn worker threads.
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">num_threads</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Worker</span>::<span class="n">new_fifo</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">stealers</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">worker</span><span class="p">.</span><span class="n">stealer</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="kr">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">worker</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">slot</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">slot_runs</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">thread</span>::<span class="n">Builder</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&#34;async-std/executor&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="kr">proc</span><span class="p">));</span><span class="w">
</span><span class="w">                </span><span class="n">abort_on_panic</span><span class="p">(</span><span class="n">main_loop</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">})</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;cannot start a thread driving tasks&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">Pool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">injector</span>: <span class="nc">Injector</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">stealers</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">sleepers</span>: <span class="nc">Sleepers</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// 工作线程的状态
</span><span class="sd"></span><span class="k">struct</span> <span class="nc">Processor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 本地任务队列
</span><span class="sd"></span><span class="w">    </span><span class="n">worker</span>: <span class="nc">Worker</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 存放了比本地队列中任务优先级更高的任务，通常第一次spawn会放到这里，
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 执行一次poll来快速判断状态，对于无阻塞的任务更高效，不需要等待。
</span><span class="sd"></span><span class="w">    </span><span class="n">slot</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// How many times in a row tasks have been taked from the slot rather than the queue.
</span><span class="sd"></span><span class="w">    </span><span class="n">slot_runs</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main_loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">find_runnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 实际上，这里根据空循环的次数，会陷入睡眠状态或出让CPU资源，直到新的task来唤醒。
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">find_runnable</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 优先从本地的队列中获取
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_local</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 其次从全局队列中获取
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_global</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// 最后尝试从其他线程的本地队列中偷取
</span><span class="c1"></span><span class="w">    </span><span class="n">steal_other</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// 安排新的任务到Executor的执行队列中
</span><span class="sd"></span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">task</span>: <span class="nc">Runnable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PROCESSOR</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="kr">proc</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// If the current thread is a worker thread, store it into its task slot or push it into
</span><span class="c1"></span><span class="w">        </span><span class="c1">// its local task queue. Otherwise, push it into the global task queue.
</span><span class="c1"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="kr">proc</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 如果当前线程为worker线程，插入到当前线程的第一优先级任务槽
</span><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="kr">proc</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// Replace the task in the slot.
</span><span class="c1"></span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">proc</span><span class="p">.</span><span class="n">slot</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">task</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 尝试把任务的优先级提升到最高，并把上一个优先级最高的任务放到当前线程任务队列
</span><span class="c1"></span><span class="w">                    </span><span class="c1">// If the slot already contained a task, push it into the local task queue.
</span><span class="c1"></span><span class="w">                    </span><span class="kr">proc</span><span class="p">.</span><span class="n">worker</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="n">POOL</span><span class="p">.</span><span class="n">sleepers</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="c1">// 如果当前线程不是worker线程的话，放到全局队列
</span><span class="c1"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 将任务放到全局队列中
</span><span class="c1"></span><span class="w">                </span><span class="n">POOL</span><span class="p">.</span><span class="n">injector</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="c1">// 尝试唤醒一个睡眠的worker线程
</span><span class="c1"></span><span class="w">                </span><span class="n">POOL</span><span class="p">.</span><span class="n">sleepers</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里做了大量的简化，整个Executor是一个线程池，每个线程都在不断的寻找可执行的task，然后执行，然后再找下一个task，再执行，永远重复。</p>
<blockquote>
<p>从上面的main_loop中可以看到，cpu并不是一直毫无意义的空转，中间会有一些策略来优化cpu的使用。</p>
</blockquote>
<a class="post-dummy-target" id="reactor"></a><h2>Reactor</h2>
<p>  <code>Reactor</code>作为反应器，上面同时挂载了成千上万个待唤醒的事件， 这里使用了<a href="https://github.com/&amp;emsp;tokio-rs/mio" target="_blank"><code>mio</code></a>统一封装了操作系统的多路复用<code>API</code>。在<code>Linux</code>中使用的是<a href="https://zh.wikipedia.org/wiki/Epoll" target="_blank"><code>Epoll</code></a>，在<code>Mac</code>中使用的则是<a href="https://zh.wikipedia.org/wiki/Kqueue" target="_blank"><code>Kqueue</code></a>，具体的实现在此不多说。</p>
<p>  在Future的基础上，出现了<code>AsyncRead/AsyncWrite/AsyncSeek</code>等抽象来描述IO操作，在执行对应的<code>Read/Write/Seek</code>操作时，如果底层的数据尚未准备好，会把所在的Future注册至Reactor。Reactor的流程如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">poll</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">events</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">is_readable</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readers</span><span class="p">.</span><span class="n">wakers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">waker</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">is_writeable</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">waker</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">writers</span><span class="p">.</span><span class="n">wakers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">waker</span><span class="p">.</span><span class="n">wake</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Reactor</code>会不断的<code>poll</code>就绪的事件，然后依次唤醒绑定在事件上的<code>waker</code>，<code>waker</code>唤醒的时候会把对应的<code>task</code>移动到<code>Executor</code>的就绪队列上安排执行。</p>
<blockquote>
<p>结合<code>Executor</code>的运作原理不难发现，<code>Executor</code>肯定不会<code>poll</code>到未就绪的<code>task</code>，因为只有就绪的任务才会被<code>Reactor</code>放到<code>Executor</code>的执行队列中，<code>Executor</code>的资源利用率再一次被提高，这就是整个异步体系的高明之处。</p>
</blockquote>
<a class="post-dummy-target" id="stream"></a><h2>Stream</h2>
<p>  <code>Future</code>是异步开发中最基础的概念了，如果说<code>Future</code>代表了一次性的异步值，那么<code>Stream</code>则代表了一系列的异步值。<code>Future</code>是1，<code>Stream</code>是0，1或者N。 签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Stream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_next</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>对应了同步原语中的<code>Iterator</code>的概念，回忆一下，是不是连签名都是如此的相像呢！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>用来抽象源源不断的数据源，当然也可以断（当 <code>poll</code> 到 <code>None</code> 的时候）。可以用来抽象 <code>Websocket Connection</code> 读取端，在<code>Websokcet</code>中，服务端源源不断的接受客户端的值并处理，直至客户端断开连接。更进一步的抽象，<code>MQ</code>中的<code>Consumer</code>, <code>Tcp</code>中接收方，都可以看作是一个<code>Stream</code>, 因此<code>Stream</code>的抽象对异步编程意义非凡。</p>
<blockquote>
<p>思考: 除了上面的几种情况，还有什么可以抽象成<code>Stream</code>模型呢？</p>
</blockquote>
<a class="post-dummy-target" id="sink"></a><h2>Sink</h2>
<p>有了代表一次性的异步值<code>Future</code>, 也有了代表可重复的异步值的<code>Stream</code>, 因此，需要有一个代表一次或多次的异步值的通道，也就是接下来的<code>Sink</code>。通常来说, <code>Sink</code>可以来抽象网络连接的写入端，消息队列中的 <code>Producer</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_ready</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">start_send</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_flush</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_close</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在Sink的上层，我们可以封装 <code>send</code> 以及 <code>send_all</code> 等方法，用来抽象对应的 <code>Future</code> 与 <code>Stream</code>.</p>
<a class="post-dummy-target" id="timer"></a><h2>Timer</h2>
<p>  很多情况下，我们希望可以延时执行一些操作，比如定时发送邮件，每隔一段时间生成一次报表。我们首先想到不就是<code>sleep</code>一段时间就行了，下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_next_day</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Time</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">hour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">current_time</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run_every_hour</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">hour</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">do_something</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>是不是很机智呢！😂😂😂！ 遗憾的是，我们写完这段代码，提交后，还没上线，估计就要滚蛋了。因此，我们想要的是一个不阻塞当前线程的定时器，定时器到期自动唤醒并执行之后的操作。</p>
<p>  不同于<code>Tcp/Udp/Uds</code>，<code>mio</code>没有提供对<code>Timer</code>的封装。</p>
<p>  通常来说，对定时器的处理要么是时间轮，要么堆，要么红黑树(时间复杂度更为平均<code>O(log n)</code>)。时间轮比较典型的案例就是在<code>Kafka</code>中的使用了，<code>Go Runtime</code> 用的则是堆，红黑树和堆的实现大致相同。</p>
<ol>
<li>时间轮算法可以想象做钟表，每一格存储了到期的定时器，因此时间轮的最小精度为每一格所代表的时间(因此时间轮算法不适合用于对精度要求高的场景)。如果定时器的时间超过时间轮所能表示的时间怎么办呢，也简单，可以通过两种方式来优化。</li>
</ol>
<ul>
<li>多级时间轮来优化，可以想象，在钟表上，秒针每走一圈，分针走一格，同理分针走一圈，时针走一格，因此多级时间轮中，第一级的时间最为精确，第二级次之，第三级再次之&hellip;, 超过某一级时间轮所能表示的事件后，将定时器放到下一级时间轮中。</li>
<li>超过时间轮所能表示的时间范围后，对时间取余，插入到余数所在的格子中，这样一来，每个格子中存放的定时器需要加入轮数的记录，用来表明还差多少轮才能执行。每个格子中在插入新的定时器时，可以使用堆来堆定时器进行排序。</li>
</ul>
<ol start="2">
<li>堆定时器(红黑树定时器)</li>
</ol>
<p>  使用最小堆来维护所有的定时器。一个工作线程不断的从堆里面寻找最近的定时器，如果定时器的时间比当前时间小，则唤醒该定时器对应的task，如果未达到设定的时间，则进行<code>Thread::park(deadline-now)</code>操作，让出当前cpu一段时间。</p>
<blockquote>
<p>目前futures-timer的实现为全剧唯一的一个堆。存在可优化空间, 比如 <code>Go 1.14</code> 的实现，把定时器提交到当前worker thread的本地堆里面，用来避免锁竞争，提高性能。</p>
</blockquote>
<a class="post-dummy-target" id="组合子"></a><h2>组合子</h2>
<p>上面定义了实现异步的最基本概念，<code>Future</code>, <code>Stream</code>以及<code>Sink</code>。</p>
<p>但是很多情况下，我们直接使用它们来构建我们的应用是非常困难的，例如：多个互为竞争关系的<code>Future</code>，我们只需其中任意一个<code>Future</code>返回即可，能想到的做法是，我们不断的遍历所有的<code>Future</code>，直到某一个返回<code>Ready</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">futures</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">is_ready</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">output</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们可以把上面的逻辑给包装一下，提供一个名为<code>select!(futures...)</code>的宏，<code>select</code>便可作为一个组合子而存在。类似的组合子还有很多，比如<code>join(futures...)</code>，等待所有<code>Future</code>完成。</p>
<p>更多的可以参考<a href="https://docs.rs/futures-util/0.3.4/futures_util/" target="_blank"><code>futures-util</code></a>.</p>
<a class="post-dummy-target" id="asyncawait"></a><h2>Async/Await</h2>
<p>上面所有的概念共同组成了<code>Rust</code>的异步生态，那么现在想象一下，如何获取一个<code>Future</code>运行的结果呢。一个可能的做法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span>::<span class="n">poll</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果每次都要用户这么做的话，将会是多么痛苦的一件事儿呀，还不如用注册回调函数来实现异步呢！</p>
<p>有没有更精炼的方式来获取<code>Future</code>的值呢，这就是<code>async/await</code>出现的原因了。本质上来说，<code>async/await</code>就是上面代码段的一个语法糖，是用户使用起来更加的自然。上面的代码可以替换成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">await</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>是不是有非常大的简化呢！</strong></p>
<a class="post-dummy-target" id="总结-1"></a><h2>总结</h2>
<p>虽然上面提到了各种各样的概念，但是仔细捋一下，便会发现整个异步可以分为三层：</p>
<ol>
<li><code>Future/Stream/Sink</code>，<code>Reactor/Executor</code>直接作用于前面的三种类型。此层是为底层，一般用户很少接触，库的开发者接触较多。</li>
<li>组合子层，为了提供更为复杂的操作，诞生了一系列的异步组合子，使得异步变得更利于使用，用户会使用这些组合子来完成各种各样的逻辑。</li>
<li><code>async/await</code>，准确的说，这层远没有上面两层来的重要，但是依然不可或缺，这层使得异步的开发变得轻而易举。</li>
</ol>
<a class="post-dummy-target" id="注意的地方"></a><h3>注意的地方</h3>
<ol>
<li>不要在任何异步函数中执行任何阻塞操作，不仅仅是<code>thread::sleep</code>, 还有标准库的<code>Tcp/Udp</code>, 以及<code>sync</code>中的<code>channel</code>, <code>Mutex</code>, <code>RWLock</code> 都不应该继续使用，除非你知道你在干什么！替换为<code>async-std</code> 与 <code>futures</code>中实现的版本。</li>
<li>如非必要，不要自己尝试去实现<code>Future</code>，自己实现的没有触发<code>wake</code>操作的话，将永远不会唤醒，取而代之，用已经实现好的<code>Future</code>进行组合。</li>
<li>使用<code>async/await</code>代替所有需要异步等待的点，这将会极大的简化你的代码。</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>本文于 2020-03-10 更新</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"><span><a href="//twitter.com/share?url=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f&amp;text=Rust%e5%bc%82%e6%ad%a5%e6%b5%85%e8%b0%88&amp;via=lidahuiya" target="_blank" title="分享到 Twitter">
            <i class="fab fa-twitter fa-fw"></i>
        </a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f" target="_blank" title="分享到 Facebook">
            <i class="fab fa-facebook-square fa-fw"></i>
        </a><a href="//reddit.com/submit?url=https%3a%2f%2fleaxoy.github.io%2f2020%2f03%2frust-async-runtime%2f&amp;title=Rust%e5%bc%82%e6%ad%a5%e6%b5%85%e8%b0%88" target="_blank" title="分享到 Reddit">
            <i class="fab fa-reddit fa-fw"></i>
        </a></span></div>
        </div>
    </div>

    <div class="post-info-more">
        <section><span class="tag">
                        <a href="https://leaxoy.github.io/tags/rust/"><i class="fas fa-tag fa-fw"></i>&nbsp;rust</a>&nbsp;
                    </span><span class="tag">
                        <a href="https://leaxoy.github.io/tags/%E5%B9%B6%E5%8F%91/"><i class="fas fa-tag fa-fw"></i>&nbsp;并发</a>&nbsp;
                    </span></section>
        <section>
            <span><a href="javascript:window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="https://leaxoy.github.io/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="https://leaxoy.github.io/2019/12/go-concurrent-saft-and-unsafe/" class="prev" rel="prev" title="Go语言并发安全与不安全"><i class="fas fa-angle-left fa-fw"></i>Go语言并发安全与不安全</a></div>
</div><div class="post-comment"></div>
    </article></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a>
        </div>

        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://leaxoy.github.io/" target="_blank">李大辉</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><script src="/js/blog.min.js"></script></body>
</html>